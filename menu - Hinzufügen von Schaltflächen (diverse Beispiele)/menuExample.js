
/*
 * Copyright 2015 d.velop AG
 */

/* The class must derive from the original template to inherit its behaviour. menuExample is the
name of the template you should use in your configuration. A class name always starts with "Template_".
All occurrences of "Template_menuExample" in the file must be replaced with the new class name, if you want to rename it */
var Template_menuExample = (function (_super) {
    __extends(Template_menuExample, _super);
    // The constructor of every class is called synchronously 
    function Template_menuExample(ctx, folder, options) {
        var _this = _super.call(this, ctx, folder, options) || this;

        /* If you want to redesign the html from the derived class, you can set it with the following assignment. It is important
        to do this here, because the html will be added to the page before the init method is called.
        You can fand a better example for this scenario in the primaryExample Template */
        //this.html = ["<div></div>"]

        // This block is reserverd for the autogenerated code from the center configurators
        // ---[ELEMENTS-CONFIG-START]---
        _this._extendDerivedConfig({});
        return _this;
        // ---[ELEMENTS-CONFIG-END]---
    }
    /* List of variables or methods you can use:

    Variables and methods, that are available in all templates:
     - cssClass: string - add a css class to the container from the template - set only in constructor
     - id: string - id of the html container for this instance - set only in constructor
     - html: Array<string> - the html templates as string array - set only in constructor
     - ctx: ElementContext
     - folder: Folder - the currently selected folder - useful in the folderview or, for example, the tabs template
     - viewType: ecspand.Args.ElementSelectedViewType - indicates in which view type the template has been opened (File, Folder, Undefined)
     - actionType: ecspand.Args.ElementSelectedActionType - in some cases it can be useful to determine, in
        which mode the view has been opened (Undefined, New, Edit, Delete, ChangeContext, Close)
     - cmid: string - the cmid (or title) of the folderplan configuration
     - parentTemplate: TemplateBase - gives access to the parent template - in this example it would be the fileCoverDefault Template
     - parent: ElementContext - in some cases it can be useful to have the parent ElementContext of the current ctx
     - options: TemplateBaseOptions - only for logging purpose
     - throbber: ecspand.Controls.Throbber - each template has its own throbber, which can be shown with this.throbber.show() and hidden with
       this.throbber.hide()
     - container: JQuery - the main container in which the template is to be rendered
    
    Variables and methods, that are available only in the Template_menu and their derivations:
     - viewModel: any - the viewModel for the buttons - contains an observable array to add the button view models (items)
     - permissions: SP.BasePermissions - contains the permissions for the current user - for further information see: http://msdn.microsoft.com/en-us/library/office/ee549745(v=office.14).aspx
    
    The template definition should look like this:
    {
        "Name": "menu",
        "ClassName": "Template_menuExample",
        "ContainerSelector": ".fileCoverMenu",
        "FileName": "menuExample",
        "Inherits": "menuDefault",
        "IsDefault": false,
        "Editable": true
    }

    */
    /* The main function which is called directly after instantiation of the class. All asynchronous initialization processes or
        the access to a html template, defined in the constructor, have to be placed here */
    Template_menuExample.prototype.init = function () {
        var _this = this;
        /* Usually you will work with asynchronous procedures to initialize your displayTemplates. So it is important do understand
        the concepts behind the jquery deferred object. At first, you just need to know that you have to call dfd.resolve() if
        your initialization has been completed. */
        var dfd = $.Deferred();
        /* In some cases you will need a variable with a reference to the current instance to use it in a different scope. For example,
        look at the click event in the openViewModel object (usually there is also a "_this" variable which can be used like the "self" variable) */
        var self = this;

        /* Do not forget to call the init method of the derived class to ensure that
        the required parts, such as controls/widgets or viewModels, will be instantiated correctly.
        The .done() call signifies, that the call returns a JQueryPromise. This JQueryPromise calls the delegate function given
        in the done call, after it calls dfd.resolve() internally */
        _super.prototype.init.call(this).done(function () {
            /* Please always ensure, that the ctx object is set, because it can be null or undefined in some cases  */
            if (_this.ctx || _this.get_templateConfiguration().get_preventAutoload()) {
                // This block is reserverd for the autogenerated code from the center configurators
                // ---[ELEMENTS-BLOCK-START]---
                // ---[ELEMENTS-BLOCK-END]---

                /* this.ctx is the main object, that we work with. It is a wrapped SP.ListItem object with additional ecspand functionality
                such as the ability to get access to the children or parent lists/libraries and the linked items/documents.
                In this case the inner block will be executed, if the element is a document and the user has the permission to edit the list item.
                */
                if (_this.folder.get_isDocumentType() && _this.permissions.has(SP.PermissionKind.editListItems)) {
                    /* this object represents a viewModel for a button in the fileCoverMenu. It consists of a title, an iconSource (in this example the default source map from
                    SharePoint, the icon style which is required to give the icon the correct position and an ordinary click event handler */
                    var openViewModel = {
                        title: "Title",
                        iconSource: "/_layouts/15/1031/images/formatmap32x32.png?rev=23",
                        iconStyle: "top: -1px; left: -70px;",
                        click: function () {
                            /* Do whatever you want
                            If you want to use the current instance of the template, you will not be able to do it with the regular this. The click handler is
                            executed in the scope of the html element and this would give you access to the viewmodel. If you want to have access to the current template
                            instance, you have to use self. or _this.
                            
                            With SP.UI.ModalDialog.showModalDialog (a default SharePoint function) you are able to open a url in a modal dialog.
                            For more information see: http://msdn.microsoft.com/en-us/library/office/ff410058(v=office.14).aspx
                            */
                            var options = {
                                title: "Title",
                                url: location.href,
                                allowMaximize: true,
                                showClose: true,
                                showMaximized: true,
                                dialogReturnValueCallback: function (result) {
                                    // the console class contains a bunch of useful functions, such as some logging capabilities (best experience in chrome)
                                    if (result === SP.UI.DialogResult.OK) {
                                        ecspand.Helper.Console.debug("The modal dialog has been closed with result OK");
                                    }
                                    else if (result === SP.UI.DialogResult.cancel) {
                                        ecspand.Helper.Console.debug("The work with the modal dialog has been cancelled");
                                    }
                                }
                            };
                            SP.UI.ModalDialog.showModalDialog(options);
                            /* Under the ecspand.ControlHelper.Common namespace you can find some useful functions like "openDropZonePage" or "openImageViewerPage"
                            which facilitate the opening of common modal dialogs
                                ecspand.ControlHelper.Common.openDropZonePage(this.ctx);
                            */
                        }
                    };
                    /* IMPORTANT!!! It is very important that you never use a insance variable like _this.ctx or self.ctx or _this.cssClass directly in a
                    a delegate function which will be bound to a html element (for example click: function() { ...). It is a better approach if you swap your handler into a seperat method like
                    Template_menuExample.prototype.onWfViewModelClick. Example follows.

                    /* Now you can add the created button to the viewmodel object of this instance, which has been bound in the derived class to the provided
                    HTML element. Kendo does the remaining work to display the button */
                    _this.viewModel.items.push(openViewModel);
                }

                /* Getting the workflowInfos (IWorkfFlowInfos) for the current item.
                Contains: workFlowInfos.WorkflowInfosCompleted, workFlowInfos.WorkflowInfosRunning, workFlowInfos.WorkflowInfosStart */
                _this.ctx.getWorkFlowInfos().done(function (workFlowInfos) {
                    var workflowName = "";
                    var info = _this.findWorkflowInfoByName(workFlowInfos.WorkflowInfosStart, workflowName);
                    // Is true, if the element is not null or undefined so it could be found
                    if (info) {
                        var wfViewModel = {
                            title: info.DisplayName,
                            workflowID: info.ID,
                            iconSource: "/_layouts/15/1031/images/formatmap32x32.png?rev=23",
                            iconStyle: "top: -275px; left: 0px",
                            click: _this.onWfViewModelClick.bind(_this)
                        };
                        _this.viewModel.items.push(wfViewModel);
                    }

                    /* With this dfd.resolve you inform the caller of the template, that all work has been done */
                    dfd.resolve();
                });

                // Refresh button - refreshes the view 
                var refreshViewModel = {
                    title: "Refresh",
                    iconSource: "/_layouts/15/1031/images/formatmap32x32.png?rev=23",
                    iconStyle: "top: -510px; left: -204px;",
                    id: "btnRefresh",
                    click: _this.onRefreshViewModelClick.bind(_this) // Use this approach if you need to access the current Instance (e.g. this.ctx) to prevent memory leaks
                };
                _this.viewModel.items.push(refreshViewModel);

                // Hauptversion veröffentlichen
                var btnPublish = {
                    title: "Veröffentlichen",
                    iconSource: "/_layouts/15/1031/images/formatmap32x32.png?rev=23",
                    iconStyle: "top:-104px; left: -378px;",
                    id: "btnPublish",
                    click: _this.onPublishClick.bind(_this)
                };
                _this.viewModel.items.push(btnPublish);

                // URL in die Zwischenablage
                var btnClipboard = {
                    title: "URL in die Zwischenablage",
                    iconSource: "/_layouts/15/1031/images/formatmap32x32.png?rev=23",
                    iconStyle: "top:-104px; left: -378px;",
                    id: "btnClipboard",
                    click: _this.onClipboardClick.bind(_this)
                };
                _this.viewModel.items.push(btnClipboard);

                // Url als Mail versenden
                var btnMail = {
                    title: "Url als Mail versenden",
                    iconSource: "/_layouts/15/1031/images/formatmap32x32.png?rev=23",
                    iconStyle: "top:-104px; left: -378px;",
                    id: "btnMail",
                    click: _this.onMailClick.bind(_this)
                };
                _this.viewModel.items.push(btnMail);
            }
            else {
                dfd.resolve();
            }
        }).fail(dfd.reject);

        // If a new element was created the actionType is New an 
        if (this.actionType === ecspand.Args.ElementSelectedActionType.New) {

        }

        /* At least, a promise object has to be returned to tell the caller, that the initialization process has not yet been completed */
        return dfd.promise();
    };


    Template_menuExample.prototype.getItemUrl = function () {

        var itemID = this.ctx.get_listItem().get_id(),
            siteUrl = this.ctx.get_site().get_url(),
            listID = this.ctx.get_list().get_id().toString(),
            url = location.origin + "/_layouts/15/ecspand/center/pages/FileView.aspx?SiteUrl=" + siteUrl + "&ListID=" + listID + "&ItemID=" + itemID;

        return url;

    };

    Template_menuExample.prototype.onClipboardClick = function () {

        // For security reasons it is not allowed to copy somithing directly into the cliboard -> workaround with a hidden input field
        var input = $("<input>").val(this.getItemUrl()).hide().appendTo(window.document.body);
        input.select();
        document.execCommand("copy");
        input.remove();

        SP.UI.Notify.addNotification("Url wurde zur Zwischenschenablage hinzugefügt", false);

    };


    Template_menuExample.prototype.onMailClick = function () {

        var link = "mailto:me@example.com"
            + "&subject=" + escape("Das könnte interessant sein")
            + "&body=" + escape(this.getItemUrl())

        window.location.href = link;
    };

    Template_menuExample.prototype.onPublishClick = function () {
        var _this = this;

        //Get current Document Version
        var version = _this.ctx.get_viewModel().get("_UIVersionString.value");

        //Prompt for action if current version is already a major version
        if (version.endsWith(".0")) {
            if (!(confirm("Dokument ist bereits eine Hauptversion (" + version + "), aktuelle Hauptversion überschreiben? \n[OK] um die aktuelle Version zu überschreiben \n[Abbrechen] um den Vorgang abzubrechen \n"))) {
                SP.UI.Notify.addNotification("<span style='color:red'>Vorgang abgebrochen</span>", false);
                return
            }
        }

        //Prompt for version comment
        var publishComment = prompt("Kommentar zur neuen Hauptversion?", "Hauptversion veröffentlicht via ecspand Center");

        //Prompt confirmed
        if (publishComment != null) {

            this.ctx.getFile().then(function (file) {

                file.publish(publishComment);
                file.refreshLoad();
                var container = ecspand.SPObjectContainer.getCurrent();
                return container.executeQueryAsync(_this.ctx.get_site().get_url());

            }).then(function () {

                SP.UI.Notify.addNotification("Datei wurde erfolgreich veröffentlicht", false);
                //Refresh Metadata
                return _this.ctx.refresh();

            }).fail(function (error) {
                SP.UI.Notify.addNotification("<span style='color:red'>" + error.notificationMessage + "</span>", false);
            });
        }
        //Prompt cancelled
        else {
            SP.UI.Notify.addNotification("<span style='color:red'>Vorgang abgebrochen</span>", false);
        }
    };

    Template_menuExample.prototype.onWfViewModelClick = function (e) {
        var _this = this;
        // Now we use the Workflow Helper Class to start the specific workflow for the current item
        var wfHelper = new ecspand.ControlHelper.Workflows(this.ctx);
        wfHelper.startWorkflow(e.data.workflowID).done(function () {
            _this.ctx.refresh();
        });
    };

    Template_menuExample.prototype.onRefreshViewModelClick = function (e) {
        var _this = this;
        this._trigger("asyncload");

        // With refresh() we force the elementContext item to refresh metadata and other elements
        // this.ctx.refresh(disableEventTriggering: boolean = false, refreshStructure: boolean = false): JQueryPromise<any>
        // if you want to force the element to refresh the whole structure (parent and child Folder) then you have to set refreshStructure = true this.ctx.refresh(true, true);
        this.ctx.refresh().always(function () {
            _this._trigger("asyncloadcompleted");
        }).fail(function (error) {
            SP.UI.Notify.addNotification("Error on refreshing the current item", false)
        });
    };
    // Helper Method to loop through to the given IWorkFlowInfoItem array and return the info object, if a workflow with the given name exists
    Template_menuExample.prototype.findWorkflowInfoByName = function (startWorkFlowInfos, workflowName) {
        if (startWorkFlowInfos && workflowName) {
            var length = startWorkFlowInfos.length;
            for (var i = 0; i < length; i++) {
                if (startWorkFlowInfos[i].DisplayName == workflowName) {
                    return startWorkFlowInfos[i];
                }
            }
        }
        return null;
    };
    // Will be called, if the parent templates have been resized
    Template_menuExample.prototype.resize = function () {
    };
    // Will be called automatically, when the template is no longer needed
    Template_menuExample.prototype.destroy = function (saveState) {

        // Call of the destroy method from the derived class to ensure that everything will be destroyed. A bit complicated because of the update compatibility
        var _this = this;
        if (saveState === void 0) { saveState = true; }
        var dfd = $.Deferred();
        var supDestroy = _super.prototype.destroy.call(this, saveState);
        if (supDestroy && supDestroy.always) {
            supDestroy.always(function () {
                /* If you have used any new objects and have bound event handler to them, you have to unbind them here to prevent memory leaks.
                Some ecspand or kendo controls/widgets got a destroy() method which handles the disposal for you.
                Examples:
                    this.ctx.bind("change", function() { ... });
                    use instead: this.ctx.bind("change.menuExample", ...)
                    and release it here with this.ctx.unbind("change.menuExample") to ensure, that the right event will be unbound

                For more examples take a look at the default templates
                */
                _this.container.empty();
                dfd.resolve();
            });
        }
        else {
            dfd.resolve();
        }
        return dfd.promise();


    };

    /* Will be called automatically before the destroy method is called internally. SaveState gives the possibility to save the current
       state of a template to restore it in the restoreState method, when the browser history has changed */
    Template_menuExample.prototype.saveState = function () {
        return _super.prototype.saveState.call(this);
    };
    Template_menuExample.prototype.restoreState = function (state) {
        return _super.prototype.restoreState.call(this, state);
    };
    return Template_menuExample;
}(Template_menu));
//# sourceURL=menuExample.js
